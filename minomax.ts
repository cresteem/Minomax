import { globSync } from "glob";
import { rmSync } from "node:fs";
import configurations from "./configLoader";
import ImageWorker from "./lib/core/image";
import ImageSetGenerator from "./lib/core/imageset";
import VideoWorker from "./lib/core/video";
import WebDocsWorker from "./lib/core/webdocs";
import {
	ConfigurationOptions,
	ImageWorkerOutputTypes,
	ImageWorkerParamsMain,
	VideoWorkerParamsMain,
} from "./lib/types";
import { copyFiles, terminate } from "./lib/utils";

export class Minomax {
	configurations: ConfigurationOptions;
	#videoWorker: VideoWorker;
	#imageWorker: ImageWorker;
	#imageGenerator: ImageSetGenerator;
	#webDocWorker: WebDocsWorker;

	constructor() {
		this.configurations = configurations();
		this.#videoWorker = new VideoWorker(this.configurations);
		this.#imageWorker = new ImageWorker(this.configurations);
		this.#imageGenerator = new ImageSetGenerator(this.configurations);
		this.#webDocWorker = new WebDocsWorker(this.configurations);
	}

	async minomax({
		imageWorkerParams,
		videoWorkerParams,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
		webDocFilesPatterns = this.configurations.webdoc.lookupPatterns,
		removeOld = this.configurations.removeOld,
	}: {
		imageWorkerParams: ImageWorkerParamsMain;
		videoWorkerParams: VideoWorkerParamsMain;
		destinationBasePath?: string;
		ignorePatterns?: string[];
		webDocFilesPatterns?: string[];
		removeOld?: boolean;
	}) {
		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		// Step:1 Pre processing
		/*  I-Delete old dest */
		if (removeOld) {
			rmSync(destinationBasePath, { force: true, recursive: true });
		}

		/* II- Copy webdoc files to dest path */
		const webDocFiles: string[] = globSync(webDocFilesPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});
		if (webDocFiles.length) {
			await copyFiles(webDocFiles, destinationBasePath);
		}

		// Step:2  I) Image set generation , II) Img tag transformation, III) Video thumbnail linking.
		const htmlPathPatterns: string[] = [...webDocFilesPatterns].filter(
			(pattern: string) => pattern.endsWith(".html"),
		);

		if (htmlPathPatterns.length === 0) {
			terminate({
				reason: "HTML pattern not found in lookupPattern, parameter",
			});
		}

		const { linkedImages, linkedVideos, videoThumbnails } =
			await this.#imageGenerator.generate({
				htmlPathPatterns: htmlPathPatterns,
				destinationBase: destinationBasePath,
				ignorePatterns: ignorePatterns,
				variableImgFormat: imageWorkerParams.targetFormat,
			});

		// Step:3 Video worker - I) Compress videos, II) Generate thumbnail of them.
		if (linkedVideos.length) {
			const { codecType, encodeLevel } = videoWorkerParams;
			const videoEncodeLevel: 1 | 2 | 3 = encodeLevel || 3;
			const thumbnailSeekPercent: number = 15;

			await this.#videoWorker.encode(
				linkedVideos,
				codecType,
				videoEncodeLevel,
				thumbnailSeekPercent,
				destinationBasePath,
			);
		}

		// Step:4 Image worker - compress images that was generated by previous worker.
		const compressedImagesDestination: string = process.cwd(); //overwriting uncompressed images with compressed

		/* I) Standard pictures */
		const imagePaths = [...linkedImages, ...videoThumbnails];
		if (imagePaths.length) {
			const { targetFormat } = imageWorkerParams;

			await this.#imageWorker.encode(
				imagePaths,
				targetFormat,
				compressedImagesDestination,
			);
		}

		/* II) SVG images */
		const svgFiles: string[] = globSync(["**/*.svg"], {
			ignore: ignorePatterns,
			cwd: destinationBasePath, //taking only generated images
			absolute: true,
		});
		if (svgFiles.length) {
			await this.#imageWorker.encode(
				svgFiles,
				"svg",
				compressedImagesDestination,
			);
		}

		// Step:5 Webdoc worker - minify HTML, JS & CSS
		const fileSearchBasePath: string = destinationBasePath; //as files were copied to destpath
		const minifiedWebDocsDestination: string = process.cwd(); //overwriting non-minified with minified files
		await this.#webDocWorker.uglify({
			webDocFilesPatterns: webDocFilesPatterns,
			destinationBase: minifiedWebDocsDestination,
			fileSearchBasePath: fileSearchBasePath,
			noDirPatterns: ignorePatterns,
		});
	}

	async compressImages({
		targetFormat = "webp",
		pathPatterns = this.configurations.imagePatterns,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		targetFormat?: ImageWorkerOutputTypes;
		pathPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const imagesFiles: string[] = globSync(pathPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});

		try {
			await this.#imageWorker.encode(
				imagesFiles,
				targetFormat,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding images", err);
			process.exit(1);
		}
	}

	async compressVideos({
		codecType = "mav1",
		pathPatterns = this.configurations.videoLookupPatterns,
		encodeLevel = 3,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		codecType?: "wav1" | "mav1" | "mx265";
		pathPatterns?: string[];
		encodeLevel?: 1 | 2 | 3;
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const videoFiles: string[] = globSync(pathPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});

		try {
			const thumbnailSeekPercent: number = 20;
			await this.#videoWorker.encode(
				videoFiles,
				codecType,
				encodeLevel,
				thumbnailSeekPercent,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding videos", err);
			process.exit(1);
		}
	}

	async minifyWebdoc({
		pathPatterns = this.configurations.webdoc.lookupPatterns,
		destinationBasePath = this.configurations.destPath,
		fileSearchBasePath = process.cwd(),
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		pathPatterns?: string[];
		destinationBasePath?: string;
		fileSearchBasePath?: string;
		ignorePatterns?: string[];
	}) {
		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		try {
			await this.#webDocWorker.uglify({
				webDocFilesPatterns: pathPatterns,
				destinationBase: destinationBasePath,
				fileSearchBasePath: fileSearchBasePath,
				noDirPatterns: ignorePatterns,
			});
		} catch (err) {
			console.error("❌ Unexpected error while minifying WebDocs.", err);
			process.exit(1);
		}
	}

	async generateImageSets({
		pathPatterns = this.configurations.imagePatterns,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		pathPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		try {
			await this.#imageGenerator.generate({
				htmlPathPatterns: pathPatterns,
				destinationBase: destinationBasePath,
				ignorePatterns: ignorePatterns,
				variableImgFormat: false,
			});
		} catch (err) {
			console.error("❌ Unexpected error while generating image set", err);
			process.exit(1);
		}
	}
}

export type minomaxOptions = ConfigurationOptions;

process.on("uncaughtException", (err) => {
	terminate({ reason: "Unhandled exception:\t" + err });
});

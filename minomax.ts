import { globSync } from "glob";
import { existsSync, rmSync } from "node:fs";
import { readFile } from "node:fs/promises";
import { cpus } from "node:os";
import { relative, sep } from "node:path";
import configurations from "./configLoader";
import ImageWorker from "./lib/core/image";
import ImageSetGenerator from "./lib/core/imageset";
import VideoWorker from "./lib/core/video";
import WebDocsWorker from "./lib/core/webdocs";
import {
	BatchSizeType,
	CodecType,
	ConfigurationOptions,
	ImageWorkerOutputTypes,
	ImageWorkerParamsMain,
	VideoWorkerParamsMain,
} from "./lib/types";
import {
	batchProcess,
	copyFiles,
	currentTime,
	deleteOldLogs,
	initProgressBar,
	logNotifier,
	logWriter,
	terminate,
	writeContent,
} from "./lib/utils";

export class Minomax {
	configurations: ConfigurationOptions;
	#videoWorker: VideoWorker;
	#imageWorker: ImageWorker;
	#imageGenerator: ImageSetGenerator;
	#webDocWorker: WebDocsWorker;

	#batchSizes: BatchSizeType = {
		//batch size based on percentage of cpu allocation.(80% of CPU)
		cPer: Math.floor((cpus().length * 80) / 100),
	};

	#beforeAll = () => {
		deleteOldLogs();
	};

	#afterAll = () => {
		logNotifier();
	};

	constructor() {
		this.configurations = configurations();

		this.#videoWorker = new VideoWorker(
			this.configurations,
			this.#batchSizes,
		);
		this.#imageWorker = new ImageWorker(
			this.configurations,
			this.#batchSizes,
		);
		this.#imageGenerator = new ImageSetGenerator(
			this.configurations,
			this.#batchSizes,
		);
		this.#webDocWorker = new WebDocsWorker(
			this.configurations,
			this.#batchSizes,
		);
	}

	async minomax({
		imageWorkerParams,
		videoWorkerParams,
		ignorePatterns = this.configurations.ignorePatterns,
		webDocFilesPatterns = this.configurations.webdoc.lookupPatterns,
		removeOld = this.configurations.removeOld,
	}: {
		imageWorkerParams: ImageWorkerParamsMain;
		videoWorkerParams: VideoWorkerParamsMain;
		ignorePatterns?: string[];
		webDocFilesPatterns?: string[];
		removeOld?: boolean;
	}) {
		this.#beforeAll();

		const destinationBasePath = this.configurations.destPath;

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const { targetFormat } = imageWorkerParams;

		// Step:1 Pre processing
		/*  I-Delete old dest */
		if (removeOld) {
			rmSync(destinationBasePath, { force: true, recursive: true });
		}

		/* II- Copy webdoc files to dest path */
		const webDocFiles: string[] = globSync(webDocFilesPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});
		if (webDocFiles.length) {
			await copyFiles(
				webDocFiles,
				destinationBasePath,
				this.#batchSizes.cPer,
			);
		}

		// Step:2
		const htmlPathPatterns: string[] = [...webDocFilesPatterns].filter(
			(pattern: string) => pattern.endsWith(".html"),
		);

		if (htmlPathPatterns.length === 0) {
			terminate({
				reason: "HTML pattern not found in lookupPattern, parameter",
			});
		}
		// 2.I) Image set generation & Img tag transformation,
		const { linkedImages, transformedHtmlFiles } =
			await this.#imageGenerator.generate({
				htmlPathPatterns: htmlPathPatterns,
				destinationBase: destinationBasePath,
				ignorePatterns: ignorePatterns,
				variableImgFormat: targetFormat,
			});

		// 2.II) Video thumbnail making & linking.
		const videoMetas = await this.makeVideoThumbnail({
			htmlFiles: transformedHtmlFiles,
			variableImgFormat: targetFormat,
			videoCodec: videoWorkerParams.codecType,
			destinationBase: destinationBasePath,
		});
		const availableVideos = Object.keys(videoMetas);
		const thumbnails = Object.values(videoMetas);

		// Step:3 Video worker - I) Compress videos
		if (availableVideos.length) {
			const { codecType, encodeLevel } = videoWorkerParams;
			const videoEncodeLevel: 1 | 2 | 3 = encodeLevel || 3;

			await this.#videoWorker.encode(
				Array.from(availableVideos),
				codecType,
				videoEncodeLevel,
				destinationBasePath,
			);
		}

		// Step:4 Image worker - compress images that was generated by previous worker.
		const compressedImagesDestination: string = process.cwd(); //overwriting uncompressed images with compressed

		/* I) Standard pictures */
		const imagePaths = [...linkedImages, ...thumbnails];
		if (imagePaths.length) {
			await this.#imageWorker.encode(
				imagePaths,
				targetFormat,
				compressedImagesDestination,
			);
		}

		/* II) SVG images */
		const svgFiles: string[] = globSync(["**/*.svg"], {
			ignore: ignorePatterns,
			cwd: destinationBasePath, //taking only generated images
			absolute: true,
		});
		if (svgFiles.length) {
			await this.#imageWorker.encode(
				svgFiles,
				"svg",
				compressedImagesDestination,
			);
		}

		// Step:5 Webdoc worker - minify HTML, JS & CSS
		const fileSearchBasePath: string = destinationBasePath; //as files were copied to destpath
		const minifiedWebDocsDestination: string = process.cwd(); //overwriting non-minified with minified files
		await this.#webDocWorker.uglify({
			webDocFilesPatterns: webDocFilesPatterns,
			destinationBase: minifiedWebDocsDestination,
			fileSearchBasePath: fileSearchBasePath,
			noDirPatterns: ignorePatterns,
		});

		this.#afterAll();
	}

	async compressImages({
		targetFormat = "webp",
		pathPatterns = this.configurations.imagePatterns,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		targetFormat?: ImageWorkerOutputTypes;
		pathPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const imagesFiles: string[] = globSync(pathPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});

		try {
			await this.#imageWorker.encode(
				imagesFiles,
				targetFormat,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding images", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async compressVideos({
		codecType = "mav1",
		pathPatterns = this.configurations.videoLookupPatterns,
		encodeLevel = 3,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		codecType?: "wav1" | "mav1" | "mx265";
		pathPatterns?: string[];
		encodeLevel?: 1 | 2 | 3;
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const videoFiles: string[] = globSync(pathPatterns, {
			ignore: ignorePatterns,
			absolute: true,
			nodir: true,
		});

		try {
			await this.#videoWorker.encode(
				videoFiles,
				codecType,
				encodeLevel,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding videos", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async makeVideoThumbnail({
		htmlFiles,
		htmlLookupPattern,
		ignorePatterns = [],
		variableImgFormat = false,
		videoCodec = false,
		destinationBase = "",
		seekPercentage = 15,
	}: {
		htmlFiles?: string[];
		htmlLookupPattern?: string[] | string;
		ignorePatterns?: string[] | string;
		variableImgFormat?: ImageWorkerOutputTypes | false;
		videoCodec?: CodecType | false;
		destinationBase?: string;
		seekPercentage?: number;
	}): Promise<Record<string, string>> {
		if (!htmlFiles && !htmlLookupPattern) {
			terminate({
				reason:
					"❌ Parameter missing: htmlFiles or htmlLookupPattern required in makeVideoThumbnail()",
			});
		}

		if (htmlLookupPattern) {
			htmlFiles = globSync(htmlLookupPattern, {
				absolute: true,
				cwd: process.cwd(),
				nodir: true,
				ignore: ignorePatterns,
			});
		}

		console.log(
			`\n[${currentTime()}] +++> ⏰ Thumbnail worker started.\n`,
		);

		let progressBar = initProgressBar({
			context: "Linking Video Thumbnails",
		});

		//linking thumnails
		const result: Record<string, string> = {}; // Record < videoPath, thumbnailPath >

		const linkPromises: (() => Promise<void>)[] = (htmlFiles || []).map(
			(htmlFile: string) => () =>
				new Promise((resolve, reject) => {
					readFile(htmlFile, { encoding: "utf-8" })
						.then((htmlContent: string) => {
							const { updatedContent, metas } =
								this.#videoWorker.videoThumbnailLinker({
									htmlFilePath: htmlFile,
									htmlContent: htmlContent,
									variableImgFormat: variableImgFormat,
									videoCodec: videoCodec,
								});

							//only hold existing videoPaths
							Object.entries(metas).forEach(
								([videoPath, thumbnailPath]) => {
									if (destinationBase) {
										const backLevel = destinationBase?.split(sep)?.length;

										videoPath = relative(process.cwd(), videoPath)
											?.split(sep)
											?.slice(backLevel)
											?.join(sep);
									}

									if (existsSync(videoPath)) {
										result[videoPath] = relative(".", thumbnailPath);
									} else {
										logWriter(`⭕ Skipping video: ${videoPath}`);
									}
								},
							);

							writeContent(updatedContent, htmlFile)
								.then(() => {
									progressBar.increment();
									resolve();
								})
								.catch(reject);
						})
						.catch(reject);
				}),
		);

		progressBar.start(linkPromises.length, 0);

		await batchProcess({
			promisedProcs: linkPromises,
			batchSize: this.#batchSizes.cPer,
			context: "Thumbnail Linker",
		});

		progressBar.stop();
		console.log("");

		//making thumbnails
		progressBar = initProgressBar({
			context: "Making Video Thumbnail",
		});

		const thumbnailPromises: (() => Promise<void>)[] = Object.keys(
			result,
		).map(
			(videoPath: string) => () =>
				new Promise((resolve, reject) => {
					this.#videoWorker
						.thumbnailGenerator({
							videoPath: videoPath,
							seekPercentage: seekPercentage,
							basepath: destinationBase,
						})
						.then(() => {
							progressBar.increment();
							resolve();
						})
						.catch((err) => {
							reject(
								`\nError while generating thumbnail for ${videoPath}\n${err}`,
							);
						});
				}),
		);

		progressBar.start(thumbnailPromises.length, 0);

		await batchProcess({
			promisedProcs: thumbnailPromises,
			batchSize: this.#batchSizes.cPer,
			context: "Video Thumbnail Maker",
		});

		progressBar.stop();

		console.log(
			`\n[${currentTime()}] ===> ✅ Thumbnails were generated & linked.`,
		);

		return result;
	}

	async minifyWebdoc({
		pathPatterns = this.configurations.webdoc.lookupPatterns,
		destinationBasePath = this.configurations.destPath,
		fileSearchBasePath = process.cwd(),
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		pathPatterns?: string[];
		destinationBasePath?: string;
		fileSearchBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		try {
			await this.#webDocWorker.uglify({
				webDocFilesPatterns: pathPatterns,
				destinationBase: destinationBasePath,
				fileSearchBasePath: fileSearchBasePath,
				noDirPatterns: ignorePatterns,
			});
		} catch (err) {
			console.error("❌ Unexpected error while minifying WebDocs.", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async generateImageSets({
		pathPatterns = this.configurations.imagePatterns,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		pathPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		try {
			await this.#imageGenerator.generate({
				htmlPathPatterns: pathPatterns,
				destinationBase: destinationBasePath,
				ignorePatterns: ignorePatterns,
				variableImgFormat: false,
			});
		} catch (err) {
			console.error("❌ Unexpected error while generating image set", err);
			process.exit(1);
		}

		this.#afterAll();
	}
}

export type minomaxOptions = ConfigurationOptions;

process.on("uncaughtException", (err) => {
	terminate({ reason: "\nUnhandled exception:\n" + err });
});

import { existsSync, rmSync } from "node:fs";
import { readFile } from "node:fs/promises";
import { cpus } from "node:os";
import { extname, relative } from "node:path";
import configurations from "./configLoader";
import ImageWorker from "./lib/core/image";
import ImageSetGenerator from "./lib/core/imageset";
import VideoWorker from "./lib/core/video";
import WebDocsWorker from "./lib/core/webdocs";
import {
	BatchSizeType,
	CodecType,
	ConfigurationOptions,
	ImageWorkerOutputTypes,
	ImageWorkerParamsMain,
	VideoEncodeLevels,
	VideoWorkerParamsMain,
} from "./lib/types";
import {
	batchProcess,
	copyFiles,
	currentTime,
	deleteOldLogs,
	getAvailableFiles,
	initProgressBar,
	logNotifier,
	logWriter,
	terminate,
	writeContent,
} from "./lib/utils";

export class Minomax {
	configurations: ConfigurationOptions;
	#videoWorker: VideoWorker;
	#imageWorker: ImageWorker;
	#imageGenerator: ImageSetGenerator;
	#webDocWorker: WebDocsWorker;

	#batchSizes: BatchSizeType = {
		//batch size based on percentage of cpu allocation.(80% of CPU)
		cPer: Math.floor((cpus().length * 80) / 100),
	};

	#beforeAll = () => {
		deleteOldLogs();
	};

	#afterAll = () => {
		logNotifier();
	};

	constructor() {
		this.configurations = configurations();

		this.#videoWorker = new VideoWorker(this.#batchSizes);
		this.#imageWorker = new ImageWorker(
			this.configurations.imageWorker.encoding,
			this.#batchSizes,
		);
		this.#imageGenerator = new ImageSetGenerator(
			this.configurations.imageWorker.set,
			this.#batchSizes,
		);
		this.#webDocWorker = new WebDocsWorker(
			this.configurations.webDoc,
			this.#batchSizes,
		);
	}

	async minomax({
		imageWorkerParams = {
			targetFormat: this.configurations.imageWorker.encoding.targetType,
		},
		videoWorkerParams = this.configurations.videoWorker.encoding,
		ignorePatterns = this.configurations.ignorePatterns,
		webDocLookUpPatterns = this.configurations.lookUpPatterns.webDoc,
		destinationBasePath = this.configurations.destPath,
		removeOld = this.configurations.removeOld,
	}: {
		imageWorkerParams?: ImageWorkerParamsMain;
		videoWorkerParams?: VideoWorkerParamsMain;
		ignorePatterns?: string[];
		webDocLookUpPatterns?: string[];
		destinationBasePath?: string;
		removeOld?: boolean;
	}) {
		this.#beforeAll();

		ignorePatterns = [...ignorePatterns, `${destinationBasePath}/**`];

		const { targetFormat } = imageWorkerParams;

		// Step:1 Pre processing
		/*  I-Delete old dest */
		if (removeOld) {
			rmSync(destinationBasePath, { force: true, recursive: true });
		}

		/* II- Copy webdoc files to dest path */
		const webDocFiles: string[] = await getAvailableFiles({
			lookUpPattern: webDocLookUpPatterns,
			ignorePattern: ignorePatterns,
			context: "WebDoc files at minomax()",
		});

		if (webDocFiles.length) {
			await copyFiles(
				webDocFiles,
				destinationBasePath,
				this.#batchSizes.cPer,
			);
		}

		// Step:2
		const htmlFiles: string[] = webDocFiles.filter(
			(filePath) => extname(filePath) === ".html",
		);

		if (htmlFiles.length === 0) {
			terminate({
				reason: "HTML files not found with given lookupPattern",
			});
		}

		// 2.I) Image set generation & Img tag transformation,
		const { linkedImages, transformedHtmlFiles } =
			await this.#imageGenerator.generate({
				htmlFiles: htmlFiles,
				destinationBase: destinationBasePath,
				variableImgFormat: targetFormat,
			});

		// 2.II) Video thumbnail making & linking.
		const videoMetas = await this.makeVideoThumbnail({
			htmlFiles: transformedHtmlFiles,
			variableImgFormat: targetFormat,
			videoCodec: videoWorkerParams.codecType,
		});
		const availableVideos = Object.keys(videoMetas);
		const thumbnails = Object.values(videoMetas);

		// Step:3 Video worker - I) Compress videos
		if (availableVideos.length) {
			const { codecType, encodeLevel } = videoWorkerParams;
			const videoEncodeLevel: 1 | 2 | 3 = encodeLevel || 3;

			await this.#videoWorker.encode(
				availableVideos,
				codecType,
				videoEncodeLevel,
				destinationBasePath,
			);
		}

		// Step:4 Image worker - compress images that was generated by previous worker.
		const compressedImagesDestination: string = process.cwd(); //overwriting uncompressed images with compressed

		/* I) Standard pictures */
		const imagePaths = linkedImages.concat(thumbnails);
		if (imagePaths.length) {
			await this.#imageWorker.encode(
				imagePaths,
				targetFormat,
				compressedImagesDestination,
			);
		}

		/* II) SVG images */
		const svgLookUpPattern: string[] = ["**/*.svg"]; //taking only generated images
		const svgFiles: string[] = await getAvailableFiles({
			lookUpPattern: svgLookUpPattern,
			ignorePattern: ignorePatterns,
			context: "SVG Files at minomax()",
			basePath: destinationBasePath,
		});

		if (svgFiles.length) {
			await this.#imageWorker.encode(
				svgFiles,
				"svg",
				compressedImagesDestination,
			);
		}

		// Step:5 Webdoc worker - minify HTML, JS & CSS
		const fileSearchBasePath: string = destinationBasePath; //as files were copied to destpath
		const minifiedWebDocsDestination: string = process.cwd(); //overwriting non-minified with minified files

		const destinatedWebDocs: string[] = await getAvailableFiles({
			lookUpPattern: webDocLookUpPatterns,
			basePath: fileSearchBasePath,
			ignorePattern: ignorePatterns,
			context: "webdocs at minomax()",
		});

		await this.#webDocWorker.uglify({
			webDocs: destinatedWebDocs,
			destinationBase: minifiedWebDocsDestination,
		});

		this.#afterAll();
	}

	async compressImages({
		targetFormat = this.configurations.imageWorker.encoding.targetType,
		lookUpPatterns = this.configurations.lookUpPatterns.image,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		targetFormat?: ImageWorkerOutputTypes;
		lookUpPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [...ignorePatterns, `${destinationBasePath}/**`];

		const imagesFiles: string[] = await getAvailableFiles({
			lookUpPattern: lookUpPatterns,
			ignorePattern: ignorePatterns,
			context: "Image Files at compressImages()",
		});

		try {
			await this.#imageWorker.encode(
				imagesFiles,
				targetFormat,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding images", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async compressVideos({
		codecType = this.configurations.videoWorker.encoding.codecType,
		lookUpPatterns = this.configurations.lookUpPatterns.video,
		encodeLevel = this.configurations.videoWorker.encoding.encodeLevel,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		codecType?: CodecType;
		lookUpPatterns?: string[];
		encodeLevel?: VideoEncodeLevels;
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [...ignorePatterns, `${destinationBasePath}/**`];

		const videoFiles: string[] = await getAvailableFiles({
			lookUpPattern: lookUpPatterns,
			ignorePattern: ignorePatterns,
			context: "Video Files at compressVideos()",
		});

		try {
			await this.#videoWorker.encode(
				videoFiles,
				codecType,
				encodeLevel,
				destinationBasePath,
			);
		} catch (err) {
			console.error("❌ Unexpected error while encoding videos", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async makeVideoThumbnail({
		htmlFiles,
		htmlLookupPattern,
		seekPercentage = 15,
		variableImgFormat = false,
		videoCodec = false,
		ignorePatterns = this.configurations.ignorePatterns,
	}: /* destinationBase = this.configurations.destPath, */
	{
		htmlFiles?: string[];
		htmlLookupPattern?: string[];
		seekPercentage?: number;
		variableImgFormat?: ImageWorkerOutputTypes | false;
		videoCodec?: CodecType | false;
		ignorePatterns?: string[] | string;
		/* destinationBase?: string; */
	}): Promise<Record<string, string>> {
		if (!htmlFiles && !htmlLookupPattern) {
			terminate({
				reason:
					"❌ Parameter missing: htmlFiles or htmlLookupPattern required in makeVideoThumbnail()",
			});
		}

		ignorePatterns = [...ignorePatterns /* `${destinationBase}/**` */];

		if (htmlLookupPattern) {
			htmlFiles = await getAvailableFiles({
				lookUpPattern: htmlLookupPattern,
				ignorePattern: ignorePatterns,
				context: "HTML Files at makeVideoThumbnail()",
			});
		}

		console.log(
			`\n[${currentTime()}] +++> ⏰ Thumbnail worker started.\n`,
		);

		let progressBar = initProgressBar({
			context: "Linking Video Thumbnails",
		});

		//linking thumnails
		const result: Record<string, string> = {}; // Record < videoPath, thumbnailPath >

		const linkPromises: (() => Promise<void>)[] = (htmlFiles || []).map(
			(htmlFile: string) => () =>
				new Promise((resolve, reject) => {
					readFile(htmlFile, { encoding: "utf-8" })
						.then((htmlContent: string) => {
							const { updatedContent, metas } =
								this.#videoWorker.videoThumbnailLinker({
									htmlFilePath: htmlFile,
									htmlContent: htmlContent,
									variableImgFormat: variableImgFormat,
									videoCodec: videoCodec,
								});

							//only hold existing videoPaths
							Object.entries(metas).forEach(
								([videoPath, thumbnailPath]) => {
									/* 	if (destinationBase) {
										const backLevel = destinationBase?.split(sep)?.length;

										videoPath = relative(process.cwd(), videoPath)
											?.split(sep)
											?.slice(backLevel)
											?.join(sep);
									} */

									if (existsSync(videoPath)) {
										result[videoPath] = relative(
											process.cwd(),
											thumbnailPath,
										);
									} else {
										logWriter(`⭕ Skipping video: ${videoPath}`);
									}
								},
							);

							writeContent(updatedContent, htmlFile)
								.then(() => {
									progressBar.increment();
									resolve();
								})
								.catch(reject);
						})
						.catch(reject);
				}),
		);

		progressBar.start(linkPromises.length, 0);

		await batchProcess({
			promisedProcs: linkPromises,
			batchSize: this.#batchSizes.cPer,
			context: "Thumbnail Linker",
		});

		progressBar.stop();
		console.log("");

		//making thumbnails
		progressBar = initProgressBar({
			context: "Making Video Thumbnail",
		});

		const thumbnailPromises: (() => Promise<void>)[] = Object.keys(
			result,
		).map(
			(videoPath: string) => () =>
				new Promise((resolve, reject) => {
					this.#videoWorker
						.thumbnailGenerator({
							videoPath: videoPath,
							seekPercentage: seekPercentage,
							basepath: process.cwd(),
						})
						.then(() => {
							progressBar.increment();
							resolve();
						})
						.catch((err) => {
							reject(
								`\nError while generating thumbnail for ${videoPath}\n${err}`,
							);
						});
				}),
		);

		progressBar.start(thumbnailPromises.length, 0);

		await batchProcess({
			promisedProcs: thumbnailPromises,
			batchSize: this.#batchSizes.cPer,
			context: "Video Thumbnail Maker",
		});

		progressBar.stop();

		console.log(
			`\n[${currentTime()}] ===> ✅ Thumbnails were generated & linked.`,
		);

		return result;
	}

	async minifyWebdoc({
		lookUpPatterns = this.configurations.lookUpPatterns.webDoc,
		lookUpBasePath = process.cwd(),
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		lookUpPatterns?: string[];
		lookUpBasePath?: string;
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const webDocs: string[] = await getAvailableFiles({
			lookUpPattern: lookUpPatterns,
			basePath: lookUpBasePath,
			ignorePattern: ignorePatterns,
			context: "webdocs at minifyWebDocs()",
		});

		try {
			await this.#webDocWorker.uglify({
				webDocs: webDocs,
				destinationBase: destinationBasePath,
			});
		} catch (err) {
			console.error("❌ Unexpected error while minifying WebDocs.", err);
			process.exit(1);
		}

		this.#afterAll();
	}

	async generateImageSets({
		lookUpPatterns = this.configurations.lookUpPatterns.image,
		destinationBasePath = this.configurations.destPath,
		ignorePatterns = this.configurations.ignorePatterns,
	}: {
		lookUpPatterns?: string[];
		destinationBasePath?: string;
		ignorePatterns?: string[];
	}) {
		this.#beforeAll();

		ignorePatterns = [
			...ignorePatterns,
			"node_modules/**",
			`${destinationBasePath}/**`,
		];

		const htmlFiles: string[] = await getAvailableFiles({
			lookUpPattern: lookUpPatterns,
			ignorePattern: ignorePatterns,
			context: "Html Files at generateImageSets()",
		});

		try {
			await this.#imageGenerator.generate({
				htmlFiles: htmlFiles,
				destinationBase: destinationBasePath,
				variableImgFormat: false,
			});
		} catch (err) {
			console.error("❌ Unexpected error while generating image set", err);
			process.exit(1);
		}

		this.#afterAll();
	}
}

export type minomaxOptions = ConfigurationOptions;

process.on("uncaughtException", (err) => {
	terminate({ reason: "\nUnhandled exception:\n" + err });
});
